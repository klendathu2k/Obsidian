## Tuesday {{date}}

- [ ] 0100PM [NPPS Distributed Software](https://docs.google.com/document/d/1L8DAzhCwpVoRM_WptpZFKqJev4-odk4xDl5rDK6JMYs/edit#heading=h.d6jxgv7ina59)[zoom](https://bnl.zoomgov.com/j/16157150845?pwd=NXNqTi9ZWEFBKzYwRXQ5U3NXU1dBZz09)


Few more thoughts on MOGO... (Memory Ordered Geometry Optimizations)

```
std::vector< std::variant< T1 .. TN > > Q;
```

That looks a bit like zebra... except that
1) It is a dynamicly sized memory store
2) It is constrained in the types that it can manage

We could think in terms of multiple containers... such as the following...

```
template<typename... Ts>
class Qstore : public std::vector< std::variant< Ts > > {

}
```

The idea being to provide a variadic template arguement specifying all of the types that the memory store can manage...

```
using MaterialStore = Qstore< TGeoMaterial, TGeoMixture >;

MaterialStore mstore;

TGeoMaterial *AddMaterial( name, a, z, dens ) {

return
   mstore.emplace_back( TGeoMaterial(name,a,z,density) );
}
...etc...
```

This would give the guarentee that all materials and mixtures would be held contiguously in memory.  Likewise media, volumes, shapes and rotation/translation matrices. 

However,  a problem arises due to the way that volumes are composed of materials, media, etc... the volume holds pointers to the constituent objects.  And those pointers will be to objects held in the memory stores.  But the memory store is a dynamic object which guarentees he pointer would be invalidated every time that the vector decides to move the object.

Looking at the reference in more detail...
https://en.cppreference.com/w/cpp/utility/variant

1) The std::variant *is default constructable*... so we can store a vector of variants and reserve space for it.
2) The std::variant constructs the object in place... it is a tagged-union... so same memory can serve to store multiple classes
3) 