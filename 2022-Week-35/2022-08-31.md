## Wednesday {{date}}

- [ ] 0830AM [NPPS Coffee](https://bnl.zoomgov.com/j/16157150845?pwd=NXNqTi9ZWEFBKzYwRXQ5U3NXU1dBZz09)
- [ ] 1000AM [sPHENIX Distributed Computing](https://bnl.zoomgov.com/j/16157150845?pwd=NXNqTi9ZWEFBKzYwRXQ5U3NXU1dBZz09)
- [ ] 1200PM [STAR S&C Meeting](https://lbnl.zoom.us/j/97026562983?pwd=VGVXbzhYUUhheEJ2cFMyVVdVRXowZz09)

More on the dynamic polymorphic ordered memory concept...

```
#include <variant>
#include <string>
#include <vector>
#include <iostream>
#include <typeinfo>

template<typename... Ts>
class Qstore : public std::vector<std::variant<Ts...>>
{

  int id;
  std::string name;

public:
  template<typename T>
  T* At( const int index ){ return std::get_if<T>( &(*this)[index] ); }
  
};


struct A {
  int a = 1;
};

struct B {
  float b = 2.0f;
};

struct C {
  double c = 3.0;
};

struct D {
  std::string d = "four";
};

Qstore< A, B, C, D > Q;

int main() {

  int j=0;
  for ( int i=0; i<100; i++ ) { 
    Q.resize(4*(i+1));
    Q[j++].emplace<A>( A{1} );
    Q[j++].emplace<B>( B{2.0f} );
    Q[j++].emplace<C>( C{3.0} );
    Q[j++].emplace<D>( D{"four"} );

  }
    
  std::cout << " ... " << std::endl;
  std::cout << "Q.size() = " << Q.size() << std::endl;
  for (auto& q: Q){
    std::visit([](auto arg){std::cout << &arg << " " << typeid(arg).name() << std::endl;}, q);
  }

  std::cout << " ... " << std::endl;
  j=0;
  for ( int i=0;i<100;i++ ) {
    A* a = Q.At<A>(j++);
    B* b = Q.At<B>(j++);
    C* c = Q.At<C>(j++);
    D* d = Q.At<D>(j++);
    std::cout << a << " " << a->a << std::endl;
    std::cout << b << " " << b->b << std::endl;
    std::cout << c << " " << c->c << std::endl;
    std::cout << d << " " << d->d << std::endl;    
  };

  return 1;

};
```

Running the above code... not agreeing with my expectations.  The pointer to the variants is significantly different than the pointers to the constructed objects.  

https://stackoverflow.com/questions/52540294/how-is-the-memory-layout-of-a-stdvector-of-stdvariant

