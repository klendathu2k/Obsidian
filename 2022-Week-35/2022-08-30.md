## Tuesday {{date}}

- [ ] 0100PM [NPPS Distributed Software](https://docs.google.com/document/d/1L8DAzhCwpVoRM_WptpZFKqJev4-odk4xDl5rDK6JMYs/edit#heading=h.d6jxgv7ina59)[zoom](https://bnl.zoomgov.com/j/16157150845?pwd=NXNqTi9ZWEFBKzYwRXQ5U3NXU1dBZz09)


Few more thoughts on MOGO... (Memory Ordered Geometry Optimizations)

```
std::vector< std::variant< T1 .. TN > > Q;
```

That looks a bit like zebra... except that
1) It is a dynamicly sized memory store
2) It is constrained in the types that it can manage

We could think in terms of multiple containers... such as the following...

```
template<typename... Ts>
class Qstore : public std::vector< std::variant< Ts > > {

}
```

The idea being to provide a variadic template arguement specifying all of the types that the memory store can manage...

```
using MaterialStore = Qstore< TGeoMaterial, TGeoMixture >;

MaterialStore mstore;

TGeoMaterial *AddMaterial( name, a, z, dens ) {

return
   mstore.emplace_back( TGeoMaterial(name,a,z,density) );
}
...etc...
```

This would give the guarentee that all materials and mixtures would be held contiguously in memory.  Likewise media, volumes, shapes and rotation/translation matrices. 

However,  a problem arises due to the way that volumes are composed of materials, media, etc... the volume holds pointers to the constituent objects.  And those pointers will be to objects held in the memory stores.  But the memory store is a dynamic object which guarentees he pointer would be invalidated every time that the vector decides to move the object.

Looking at the reference in more detail...
https://en.cppreference.com/w/cpp/utility/variant

1) The std::variant *is default constructable*... so we can store a vector of variants and reserve space for it.
2) The std::variant constructs the object in place... it is a tagged-union... so same memory can serve to store multiple classes
3) The *object* held within the variant can do whatever the object would normally do... so no issues with TGeoPcon allocating space for the z-sections (beyond the non-optimization of the memory...)  

So... some conclusions here.  
1) We can use std::variant (and quite possibly std::any) to create a dynamic polymorphic memory store
2) Said containers would provide strong guarentee that objects are placed in a contiguous block of memory
3) There would be no guarentee that memory locations would remain constant after any emplace_back operation. 
4) However, the memory store could be reserved at run time... allowing a static allocation.... so long as 
5) 
-----------------------------
