## Tuesday {{date}}

- [ ] 0100PM [NPPS Distributed Software](https://docs.google.com/document/d/1L8DAzhCwpVoRM_WptpZFKqJev4-odk4xDl5rDK6JMYs/edit#heading=h.d6jxgv7ina59)[zoom](https://bnl.zoomgov.com/j/16157150845?pwd=NXNqTi9ZWEFBKzYwRXQ5U3NXU1dBZz09)


Few more thoughts on MOGO... (Memory Ordered Geometry Optimizations)

```
std::vector< std::variant< T1 .. TN > > Q;
```

That looks a bit like zebra... except that
1) It is a dynamicly sized memory store
2) It is constrained in the types that it can manage

We could think in terms of multiple containers... such as the following...

```
template<typename... Ts>
class Qstore : public std::vector< std::variant< Ts > > {

}
```

The idea being to provide a variadic template arguement specifying all of the types that the memory store can manage...

```
using MaterialStore = Qstore< TGeoMaterial, TGeoMixture >;

MaterialStore mstore;

TGeoMaterial *AddMaterial( name, a, z, dens ) {

return
   mstore.emplace_back( TGeoMaterial(name,a,z,density) );
}
...etc...
```

This would give the guarentee that all materials and mixtures would be held contiguously in memory.  However, the pointer would be invalidated every time that the vector decides to move the object.